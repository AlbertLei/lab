---
title: "list, loops, data frame (W4)"
date: '2019-10-03'
output:
  html_document:
    number_sections: no
    theme: united
    highlight: tango
    toc: yes
    toc_float:
      collapse: no
    css: style.css
    md_extensions: +implicit_figures
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,comment = '#>',message = F)
```

```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy(position = c('top', 'right'),color = 'darkred')
```

```{js echo=FALSE}
window.onload = () => {
    if (window.location.href.startsWith('https://rlads2019.netlify.com/lab/') ||
        window.location.href.startsWith('file:///home/liao/Desktop/Lab/')) {
        document.querySelectorAll('.hide').forEach(ele => {
            ele.className = 'note';
        })
    }
}
```


## list

- vector 是 R 裡面最「簡單」的資料結構。有時候我們需要比較更複雜的資料結構處理我們遇到的資料，例如，我們或許需要儲存**不同資料類型**或是**具有階層結構**的資料。面對這兩種需求，vector 無能為力，因此需要用到 R 的 list。

- R 可以透過 `list()` 去製造出 list。`list()` 的使用方式很類似用來製造 vector 的 `c()`，但與 `c()` 不同的是，`list()`
    1. 能使用**不同的資料類型**
    2. 具有階層結構，亦即，`list()` 裡面可以放入另一個 `list()`
    
    ```{r}
    list(0.1, "Hello", TRUE)
    
    list(1.1, list(2.1, "Hello"))
    ```

### Subsetting

- 通常我們會習慣為 list 加上名字 (`names`)，幫助我們更容易處理這種比較複雜的資料結構

- `[]`: 與 vector 一樣，我們可以透過 `lst[<char vector of names>]`、`lst[<integer vector>]` 或 `lst[<logical vector>]` 去 subset list

    ```{r}
    ben <- list(age = 20, single = FALSE, tags = c("ig", "selfie"))
    
    ben['single']
    ben[2:3]
    ben[c(TRUE, FALSE, TRUE)]
    ```

- 就像 `vec[<some vector>]` 會回傳**一部分的 vector (sub-vector)**；`lst[<some vector>]` 也會回傳**一部分的 list (sub-list)**。換言之，使用 `[]` 時，回傳值的**資料結構不會改變**。

- 我們可以將 list 想像成一列火車，每節車廂是一個長度為 1 的 sub-list，車廂**裡面**是這個 sub-list 儲存的值。欲取得 sub-list，使用的是 `[]`；欲取得 sub-list **裡面的值** (i.e. 脫去外層的 list)，需使用 `[[]]`

    ```{r results='hold'}
    # 回傳 sub-list
    typeof(ben["tags"])
    ben["tags"]
    
    # 回傳 list 之內的「值」，在此為一個 char vector
    typeof(ben[["tags"]])
    ben[["tags"]]
    ```
    - `lst[["<name>"]]` 有另一種更簡便的寫法：`lst$<name>`, e.g. `ben[["tags"]]` 可改寫成 `ben$tags`


![list as a train analogy](https://img.yongfu.name/rlads/list-train.png)


### Nested Structure

```{r results='hold'}
a_lst <- list(name = "ben",
              info = list(age = 20,
                          tags = c("ig", "selfie")))

# Get "selfie"
a_lst[['info']]
a_lst[['info']][['tags']]
a_lst[['info']][['tags']][2]
```

```{r results='hold'}
# Another way to get "selfie"
a_lst['info'][[1]]
a_lst['info'][[1]]['tags'][[1]]
a_lst['info'][[1]]['tags'][[1]][2]
```

```{r results='hold'}
# Yet another way to get "selfie"
a_lst[[2]]
a_lst[[2]][[2]]
a_lst[[2]][[2]][2]
```



## for Loops

- 上週介紹的條件式 (if-else) 讓我們可以依據不同狀況執行不同的程式碼，藉此能幫助我們寫出更有彈性的程式。迴圈讓我們能重複執行某一區塊的程式碼，如此就不需要重複寫出相同的程式碼。

- 在 R 裡面有 for 與 while 兩種迴圈。一般而言，在資料分析時非常少會使用到 while 迴圈，因此實習課不作介紹，有興趣的同學可自行參考線上教材或教科書。

- for loop 的結構如下

    ```r
    for (<變數> in <vector>) {
        <some code>
    }
    ```
    
- for loop 會使 `{}` 內的程式碼重複執行數次，其次數等於 `<vector>` 的長度；並且，在第 n 次開始執行 `{}` 內的程式碼前，會將 `<vector>` 裡的第 n 個元素指派給 `<變數>`。所以在第一次迴圈時，可透過 `<變數>` 取得 `<vector>` 中的第一個元素；在第二次迴圈時，可取得 `<vector>` 中的第二個元素；依此類推，最後一次迴圈則可以透過 `<變數>` 取得 `<vector>` 中的最後一個元素。

```{r}
vec <- c("謝", "老師", "好", "帥")
  
for (word in vec) {
    # Will execute 4 times, 
    # each time a new value from `vec` will be assigned to `word`
    print(word)
}
```

### for loop 的各種型態

- R 的 for 迴圈本質上的結構是相同的，但因為 R 向量式程式語言的特性，R 的 for 迴圈很容易改寫成其它更方便使用的型態。

1. 有時候我們需要知道**迴圈進行到 `<vector>` 的第幾個元素**，這時候通常會使用 `seq_along(<vector>)` 去製造出與 `<vector>` 等長的整數序列 (e.g. `seq_along(c('a', 'b', 'c'))` 會回傳 `1 2 3`)，如此我們便可知道進行到第幾次迴圈，也可透過 `<vector>[i]` 取得與該次迴圈對映的元素。

    ```{r}
    vec <- c("謝", "老師", "好", "帥")
      
    for (i in seq_along(vec)) {
        print(paste(i, vec[i]))
    }
    
    vec <- c("謝", "老師", "好", "帥")
    
    for (i in seq_along(vec)) {
        print(vec[i])
        
        # Print `?` in the last loop
        if (i == length(vec)) {
            print('?')
        }
    }
    ```

2. 我們也可以透過 `names()` 在 for loop 裡使用 `<vector>` 的 names 屬性：

    ```{r}
    vec <- c(Monday = "rainy", Tuesday = "cloudy", Wednesday = "sunny")
    
    for (name in names(vec)) {
        print(paste0(name, ' was ', vec[name], '.'))
    }
    ```



## Wrap up：for loop 與 list

- 上週我們使用過 3 個長度為 4 的 vector 來儲存關於 4 個人 (`kai`, `jessy`, `joy`, `ben`) 的資料。但使用這種方式儲存資料似乎有些違反直覺，因為它將關於一個人的資訊 (`name`, `age`, `about`) 分開來儲存在 3 個獨立的 vector。

    ```{r}
    # Data
    name <- c("kai", "jessy", "joy", "ben")
    age <- c(40, 20, 18, 19)
    about <- c("a professor", "a cat lover", "a hacker", "a YouTuber")
    ```

- 對於這種彼此之間具有關聯的資料，一種更好的方式是將它們**儲存在一起**，因為這不只幫助我們在「程式上」更容易去操弄這筆資料，更讓我們能以「階層組織」去「想像」我們的資料。這裡我們使用 `list` 去改寫上週的資料：

    ```{r}
    member <- list(
        kai = list(age = 40, about = "a professor"),
        jessy = list(age = 20, about = "a cat lover"),
        joy = list(age = 18, about = "a hacker"),
        ben = list(age = 19, about = "a YouTuber")
    )
    
    member
    ```

    ```{r}
    for (name in names(member)) {
        someone <- member[[name]]
        
        # 將組成句子的片語儲存於 char vector `phrases`
        phrases <- c(name, someone$about, "is quite young.")
        if (someone$age > 35) {
            phrases[3] <- "should be wise."
        }
        
        # 在各片語之間插入逗點，形成一個句子
        print(paste(phrases, collapse = ', '))
    }
    ```


## data frame

```{r}
library(tibble)

df <- tibble(name = c("kai", "jessy", "joy", "ben"),
             age  = c(40, 20, 18, 19), 
             grad = c(FALSE, TRUE, FALSE, TRUE))
df
```

```{r results='hold'}
dim(df)    # 形狀 (# of rows, # of columns)
nrow(df)   # number of rows
ncol(df)   # number of columns
names(df)  # name of each column
```

```r
View(df)   # view df in RStudio source pane
```

### Subsetting: returning a data frame

```{r}
df[2, 1]
df[2, 1:2]  # df[2, c("name", "age")]
df[2, ]
```

### Subsetting: returning a column (vector)

```{r results='hold'}
df[[2]]
df[['age']]
df$age  # 最常見
```

```{r}
over19 <- df$age > 19  
over19  # logical vector of length 4 (num of rows in df)

# subset df with obs. over 19
df[over19, ]
# subset df with obs. below or equal 19
df[!over19, ]  # df[df$age <= 19, ]
```

