---
title: "pn: Web API (W11)"
date: '2019-11-21'
output:
    html_document:
        number_sections: no
        theme: united
        highlight: tango
        toc: yes
        toc_float:
            collapsed: no
        css: style.css
        md_extensions: +implicit_figures
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=T,
                      results = 'hide',
                      comment = '#>',
                      message = F,
                      out.width = '80%',
                      fig.align = 'center')
library(ggplot2)
```

```{js echo=FALSE}
window.onload = () => {
        document.querySelectorAll('.hide').forEach(ele => {
            ele.className = 'note';
        })
}
```

## Openning

<div class="hide" data-tag="Openning">
1. Text mining --> 從網路取得 (文本) 資料
1. 2 種方式
    - 1st: 整理好的 (結構化) 資料，讓你透過程式化的方式直接取得資料 (本週)
    - 2nd: 網路爬蟲，(在無從取得結構化資料時)，透過剖析網頁裡 HTML 的資訊，抓出想要的資料 (最後一堂實習課)
1. 在開始之前，介紹一個網路相關的知識 -- HTTP
</div>


## HTTP

<div class="hide" data-tag="slide">
1. HTTP 的全名是 Hypertext transfer protocal (不要被這炫炮名字嚇到)
1. HTTP 是網路上，電腦與電腦 (伺服器) 之間進行溝通時，所遵循的一套規則
    - 當每一台電腦都 follow 這個規則的時候，它們才能順利的溝通
1. (flow chart)
    1. 在瀏覽器輸入 URL
    1. 瀏覽器就會幫你**向位於這 URL 的伺服器**送出一個 HTTP request  
    (e.g. `google.com` --> 向 Google 的伺服器送出 HTTP request)
    1. Google 的伺服器接收到這個 request 後，
        1. 就會去「解讀」這個 request 的內容 (了解這個 request 要幹麻)
        1. 了解之後，它就會知道你想要什麼東西，然後把這些東西放在 HTTP response 裡面，再傳回你的電腦
    1. 電腦裡面的瀏覽器在接收到這個 HTTP response 之後
        - 就會把**儲存在裡面的資訊** (e.g. HTML)，轉換成你在螢幕上所看到的漂亮的網頁
        - (JSON) 有時候，儲存在 HTTP response 裡面的不是 HTML，而是其它純文字的格式 (例如，JSON)
            - 這時你就會看到螢幕上，是「原始純文字的樣子」，而非「經過轉換的」網頁的樣子

1. (HTML vs. JSON)
    - HTML 與 JSON 是使用網路時，常會遇到的兩種純文字格式
    - HTML: 
        - 漂亮的網頁用 HTML 寫成
        - 換言之，HTML 其實是給「人」看的 -->  
        HTML 中的許多元素是為了讓「網頁」更漂亮、互動性更強  
        因此，結構複雜、檔案較大
    - JSON: 目的是為了提供**結構化的資訊**，方便程式去處理
        - 所以當伺服器所回傳的是 JSON 格式，代表它希望的是**使用者透過程式與自己互動**
        - 因此他提供的不是一個漂亮的網頁界面，而是一個 **Web API**，讓使用者可以透過「程式的方式」去取得他所想要的資訊
    - 回到前面，兩種從網路取得資料的方式
        - 可以選擇的話，使用 Web API
            - 處理 HTML 很麻煩、伺服器負擔大
</div>


## URL Structure

<div class="hide" data-tag="Demo with Browser">
**Foreign Exchange rates API**

1. 進入 API 說明文件
    - 簡介：JSON 格式
1. `/latest`
    - 比較回傳的 JSON (擠成一坨) 與 說明文件的 JSON (漂亮)
1. `/latest?base=USD`
    - 如果閱讀過說明文件  
    可以提供給 server 一些額外的資訊，依據這些資訊，server 會回傳不同的東西
    - 提供額外資訊的方式：在 URL 之後加上 key-value pairs
        - 在加入這些資訊之前，需要加入一個 **`?`**
1. `/latest?base=USD&symbols=JPY`
    - 除了 `base` 之外，還可以提供其它的 parameter
    - 例如，只關心**美元兌日圓**的匯率


**Your Turn (4 min)**

- `/history?start_at=2017-01-03&end_at=2017-01-03&base=USD&symbols=JPY`


**URL 結構**

1. 分 3 部份
    1. Base URL
    1. Path
    1. Query string
</div>


## httr

<div class="hide" data-tag="slide, demo">
**slide:** 

1. 用 R 跟伺服器互動
1. GET request, POST request 

**demo**

1. 

    ```r
    library(httr)
    library(dplyr)
    
    GET('https://api.exchangeratesapi.io/history?start_at=2017-01-03&end_at=2017-01-03')
    
    GET('https://api.exchangeratesapi.io/',
        path = 'history',
        query = list(start_at = "2017-01-03",
                     end_at = "2017-01-03")
        )
    
    req <- GET('https://api.exchangeratesapi.io/',
        path = 'history',
        query = list(start_at = "2017-01-03",
                     end_at = "2017-01-03")
        )
    
    # req is a list (See environment)
    ```

1. URL

    ```r
    req[["url"]]
    ```

1. Status code

    ```r
    req[["status_code"]]
    ```
    
    - 404 Not found: **404** 即是 status code
    - status code 目的：告訴你 HTTP request 是否成功
    - status code 以 4** 開頭的，代表失敗, 2** 開頭代表成功

1. content --> parsed R object (not JSON string)

    ```r
    content(req)
    
    content(req, as = "text") %>% cat()
    ```

1. Raw HTML

    ```r
    rlads <- GET("https://rlads2019.github.io/")
    # Return raw HTML string
    content(rlads, as = "text")
    ```
</div>

- **3 min**



## JSON

<div class="hide" data-tag="slide, demo">
**slide:** Explain JSON format

1. 花括號內: 無序 key-value pairs
1. value: 4 types
1. value: 可以放入「一整個由花括號包裹起來的 key-value pairs」
    - 階層結構
1. array

(next slide)

1. 和 R 的 list 很像

**demo**

```r
json_str = '{
  ...
}'

jsonlite::fromJSON(json_str1, simplifyVector = F)
```

- Explain `simplifyVector`
</div>

